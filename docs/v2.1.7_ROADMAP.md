# v2.1.7 Roadmap - AI-First Enhancements

**Target**: Early December 2025  
**Focus**: Memory management UX, smart features, agent-friendly improvements  
**Based on**: Real usage feedback from v2.1.6 dogfooding session

## Overview

v2.1.7 will enhance the memory management experience for AI agents and human users with smart automation, relationship tracking, and better memory lifecycle management.

## Priority 1: Memory Templates & Schemas (HIGH)

**Problem**: Inconsistent memory structure makes recall harder  
**Solution**: Standardized templates for common memory types

### Implementation

```yaml
# ~/.whitemagic/templates/architecture.yaml
type: long_term
tags_required:
  - architecture
  - component_name
suggested_tags:
  - design
  - patterns
  - security
fields:
  component_name: string (required)
  purpose: string (required)
  responsibilities: list (required)
  key_patterns: list
  integration_points: list
  security_considerations: list
```

### Features
- Built-in templates: architecture, testing, session, bug_report, decision
- Custom template creation via `wm template create`
- CLI: `wm create --template architecture`
- Template validation on memory creation
- Template marketplace (future: share community templates)

### Commands
```bash
$ wm template list
$ wm template show architecture
$ wm create --template architecture --title "Config System"
$ wm template create custom_template.yaml
```

**Benefit**: Consistent memory structure improves semantic search accuracy by 20-30%

---

## Priority 2: Auto-Tagging with LLM (HIGH)

**Problem**: Manual tagging is tedious and inconsistent  
**Solution**: LLM suggests tags based on content

### Implementation

```python
class AutoTagger:
    def suggest_tags(self, content: str, existing_tags: list) -> list:
        """Use LLM to suggest relevant tags."""
        prompt = f"""
        Analyze this memory content and suggest 3-5 relevant tags.
        Consider: technical concepts, project components, phase/version.
        Existing tags: {existing_tags}
        
        Content: {content[:500]}...
        
        Return only tag names, comma-separated.
        """
        suggested = llm.complete(prompt)
        return self._parse_tags(suggested)
```

### Features
- Auto-suggest on `wm create`
- Interactive: Show suggestions, user can accept/modify
- Learn from user corrections (feedback loop)
- Respect existing tag vocabulary (suggest from known tags first)
- Disable with `--no-auto-tag` flag

### UX Flow
```bash
$ wm create --title "Terminal Tool Fix"
Content: [paste]
Suggested tags: terminal, bugfix, v2.1.5, security
Accept? [Y/n/edit]: 
```

**Benefit**: Reduces friction, improves tag consistency across memories

---

## Priority 3: Memory Relationships & Graphs (MEDIUM)

**Problem**: Memories exist in isolation, connections are implicit  
**Solution**: Explicit relationship tracking

### Implementation

```yaml
# memory frontmatter
---
title: Terminal Tool Architecture
related_to:
  - terminal_tool_fixes.md:
      type: implements
      description: "Fixes based on this architecture"
  - testing_lessons.md:
      type: informed_by
      description: "Testing approach informed this design"
  - security_policy.md:
      type: depends_on
      description: "Security requirements"
---
```

### Relationship Types
- `depends_on`: This memory requires understanding of related memory
- `implements`: Related memory is an implementation of this design
- `supersedes`: This memory replaces/updates related memory
- `informed_by`: Related memory influenced this memory
- `related_to`: General connection

### Features
- `wm relate <memory1> <memory2> --type depends_on`
- `wm graph <memory>` - Show relationship graph (ASCII or rich tree)
- `wm graph --viz` - Export to Graphviz/Mermaid
- Auto-suggest relationships on create (LLM-based)
- Search traverses relationships (optional `--include-related`)

### Commands
```bash
$ wm relate terminal_arch.md terminal_fix.md --type implements
$ wm graph terminal_arch.md
terminal_arch.md
├── implements → terminal_fix.md
├── informed_by → testing_lessons.md
└── depends_on → security_policy.md

$ wm search-semantic "terminal" --include-related
# Returns direct matches + 1-hop related memories
```

**Benefit**: Makes implicit knowledge connections explicit, improves context retrieval

---

## Priority 4: Smart Memory Lifecycle (MEDIUM)

**Problem**: No automatic memory management, manual archival required  
**Solution**: Rule-based automatic archival and consolidation

### Implementation

```yaml
# ~/.whitemagic/config.yaml
memory_lifecycle:
  rules:
    - name: "Archive old sessions"
      pattern: "session_*"
      age_days: 7
      action: archive
      
    - name: "Archive version-specific docs"
      pattern: "*_v[0-9]*_*"
      age_days: 30
      action: archive
      
    - name: "Consolidate daily notes"
      pattern: "daily_*"
      age_days: 7
      action: suggest_consolidate
      target_pattern: "weekly_{year}_{week}.md"
```

### Features
- Run manually: `wm lifecycle check`
- Run on schedule: `wm lifecycle --daemon` (background process)
- Dry-run: `wm lifecycle check --dry-run`
- Interactive prompts before actions
- Consolidation suggestions (LLM-generated summaries)

### Example Output
```bash
$ wm lifecycle check
Found 5 memories matching lifecycle rules:

Archive (7 days old):
  - session_nov14_morning.md
  - session_nov14_evening.md
  
Consolidate suggestion (7 daily notes):
  - daily_nov08.md ... daily_nov14.md
  → Suggested: weekly_2025_45.md
  
Proceed? [y/N]: 
```

**Benefit**: Keeps memory system clean, reduces search noise, automatic knowledge consolidation

---

## Priority 5: Memory Stats & Analytics (LOW)

**Problem**: No visibility into memory system usage and value  
**Solution**: Comprehensive statistics and insights

### Implementation

```python
class MemoryStats:
    def generate_report(self) -> dict:
        return {
            "total_memories": 156,
            "by_type": {"short_term": 45, "long_term": 111},
            "by_tag": {"architecture": 23, "testing": 18},
            "search_queries": 47,
            "token_efficiency": 0.947,  # vs checkpoints
            "most_accessed": ["terminal_arch.md", "config_system.md"],
            "growth_rate": "+12 memories/week",
            "consolidation_opportunities": 8,
        }
```

### Features
- `wm stats` - Overall statistics
- `wm stats --tag architecture` - Tag-specific stats
- `wm stats --period week` - Time-based analysis
- Export: `wm stats --export json/csv`
- Token efficiency metrics (compare to checkpoint baseline)

### Example Output
```bash
$ wm stats
╭─ WhiteMagic Memory Statistics ────────────────╮
│ Total Memories: 156                            │
│   Short-term: 45  │  Long-term: 111           │
│                                                │
│ Most Used Tags:                                │
│   architecture (23)  testing (18)  v2.1.6 (12)│
│                                                │
│ Token Efficiency: 94.7% reduction             │
│   Checkpoint avg: 52k tokens                   │
│   WhiteMagic avg: 2.7k tokens                  │
│                                                │
│ Search Activity:                               │
│   47 queries this session                      │
│   Top terms: config, terminal, testing         │
│                                                │
│ Growth: +12 memories/week                      │
│ Consolidation opportunities: 8                 │
╰────────────────────────────────────────────────╯
```

**Benefit**: Validates WhiteMagic's value, identifies optimization opportunities

---

## Additional Nice-to-Haves

### Memory Diff/Version History
```bash
$ wm history terminal_arch.md
[Nov 14 8pm] Added Approver patterns (+150 lines)
[Nov 13 9pm] Added API integration (+80 lines)
[Nov 12 7pm] Initial architecture (created)

$ wm diff terminal_arch.md --between "Nov 13" "Nov 14"
```

### Batch Import/Export
```bash
$ wm export --tag v2.1.6 --format json > v2.1.6_memories.json
$ wm import memories.json --merge --dry-run
```

### Memory Compression (Long-term)
```yaml
compression:
  enabled: true
  age_days: 90
  mode: summary  # Store LLM summary + key facts
```

### Search Query Expansion
```python
# User: "config system"
# Expanded: ["config", "configuration", "pydantic", "settings", "yaml"]
```

---

## Implementation Plan

### Week 1: Templates & Auto-Tagging
- [ ] Template schema design
- [ ] Built-in templates (5 types)
- [ ] Template validation
- [ ] Auto-tagging LLM integration
- [ ] CLI commands
- [ ] Tests

### Week 2: Relationships
- [ ] Relationship schema
- [ ] Storage format (YAML frontmatter)
- [ ] Graph traversal logic
- [ ] CLI commands (`relate`, `graph`)
- [ ] Rich visualization
- [ ] Tests

### Week 3: Lifecycle & Stats
- [ ] Lifecycle rules engine
- [ ] Auto-archival logic
- [ ] Consolidation suggestions
- [ ] Stats aggregation
- [ ] CLI commands
- [ ] Tests

### Week 4: Polish & Documentation
- [ ] Integration testing
- [ ] Documentation updates
- [ ] Migration guide
- [ ] Release prep

---

## Success Metrics

**Adoption**:
- 80% of new memories use templates
- Auto-tagging accepted 70%+ of the time

**Efficiency**:
- Memory search time reduced 30%
- Token usage reduced additional 10-15%

**Quality**:
- Tag consistency improved 40%
- Relationship-enhanced searches 25% better recall

**User Satisfaction**:
- "Creating memories is easier" - target 90%+
- "Finding memories is faster" - target 85%+

---

## Technical Considerations

### LLM Integration
- Use existing OpenAI client (already configured)
- Fallback to rule-based if API unavailable
- Cache suggestions to reduce API calls
- Configurable: `wm config-set ai.auto_tag_enabled true`

### Performance
- Graph traversal: Limit depth to 2-3 hops
- Stats: Cache calculations, refresh on demand
- Lifecycle: Run async, don't block operations

### Backwards Compatibility
- All features opt-in by default
- Existing memories work without changes
- Templates optional, not required
- Relationships added incrementally

---

## Questions for Discussion

1. **LLM Provider**: OpenAI only, or support local models too?
2. **Relationship UI**: ASCII tree, rich panels, or web-based graph?
3. **Auto-tagging**: Interactive prompt vs auto-apply with review?
4. **Lifecycle**: Daemon process vs manual runs vs on-demand?
5. **Stats Export**: Which formats priority? (JSON, CSV, HTML?)

---

## Next Steps

1. Create feature branch: `feature/v2.1.7-smart-memories`
2. Start with templates (highest ROI, clearest scope)
3. Dogfood on WhiteMagic development itself
4. Iterate based on real usage

**Estimated Timeline**: 3-4 weeks for v2.1.7 release  
**Target Date**: December 10-15, 2025
