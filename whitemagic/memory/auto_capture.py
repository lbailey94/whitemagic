"""
Automatic memory capture system for WhiteMagic v2.3.1.

Captures short-term memories every N actions to enable:
- Tactical reasoning tracking
- Pattern extraction
- Meta-learning
- Self-improvement
"""

import os
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
import json


@dataclass
class Action:
    """Single action taken by the AI."""
    action_type: str
    description: str
    reasoning: str
    outcome: str
    timestamp: float
    tags: List[str]
    metadata: Dict[str, Any]


@dataclass
class ShortTermMemory:
    """Short-term memory entry."""
    action_count: int
    actions: List[Action]
    learning: str
    next_steps: str
    timestamp: float
    tags: List[str]
    
    def to_markdown(self) -> str:
        """Convert to markdown format."""
        dt = datetime.fromtimestamp(self.timestamp)
        
        # Header
        md = f"""---
type: short_term
action_count: {self.action_count}
timestamp: {dt.isoformat()}
tags: {json.dumps(self.tags)}
---

# Short-Term Memory #{self.action_count}

**Generated**: {dt.strftime('%Y-%m-%d %H:%M:%S')}

## Actions Taken

"""
        
        # Actions
        for i, action in enumerate(self.actions, 1):
            md += f"""
### {i}. {action.action_type}

**Description**: {action.description}

**Reasoning**: {action.reasoning}

**Outcome**: {action.outcome}

**Tags**: {', '.join(action.tags)}

"""
        
        # Learning and next steps
        md += f"""
## What I Learned

{self.learning}

## Next Steps

{self.next_steps}

---
*Auto-generated by WhiteMagic v2.3.1 Memory Evolution System*
"""
        
        return md


class MemoryCapture:
    """Automatic memory capture system."""
    
    def __init__(self, base_dir: Optional[Path] = None, frequency: int = 5):
        """
        Initialize memory capture.
        
        Args:
            base_dir: Base directory for memories (default: memory/)
            frequency: Capture frequency (every N actions)
        """
        self.base_dir = base_dir or Path("memory")
        self.short_term_dir = self.base_dir / "short_term"
        self.frequency = frequency
        self.max_short_term = 60
        
        # Action buffer
        self.actions: List[Action] = []
        self.action_count = 0
        
        # Ensure directories exist
        self.short_term_dir.mkdir(parents=True, exist_ok=True)
        
        # Load existing count
        self._load_action_count()
    
    def _load_action_count(self):
        """Load action count from existing memories."""
        existing = list(self.short_term_dir.glob("*.md"))
        if existing:
            # Parse action counts from filenames
            counts = []
            for path in existing:
                try:
                    # Format: YYYYMMDD_HHMMSS_action_NNN.md
                    parts = path.stem.split('_')
                    if len(parts) >= 4 and parts[2] == 'action':
                        counts.append(int(parts[3]))
                except:
                    pass
            
            if counts:
                self.action_count = max(counts)
    
    def record_action(
        self,
        action_type: str,
        description: str,
        reasoning: str = "",
        outcome: str = "",
        tags: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None
    ):
        """
        Record a single action.
        
        Args:
            action_type: Type of action (e.g., 'file_read', 'edit', 'analysis')
            description: What was done
            reasoning: Why it was done
            outcome: What happened
            tags: Categorization tags
            metadata: Additional context
        """
        self.action_count += 1
        
        action = Action(
            action_type=action_type,
            description=description,
            reasoning=reasoning,
            outcome=outcome,
            timestamp=time.time(),
            tags=tags or [],
            metadata=metadata or {}
        )
        
        self.actions.append(action)
        
        # Auto-capture if frequency reached
        if len(self.actions) >= self.frequency:
            self.capture_memory()
    
    def capture_memory(self, force: bool = False):
        """
        Capture current actions as short-term memory.
        
        Args:
            force: Force capture even if frequency not reached
        """
        if not self.actions and not force:
            return
        
        # Extract learning
        learning = self._extract_learning()
        
        # Determine next steps
        next_steps = self._determine_next_steps()
        
        # Extract tags
        all_tags = set()
        for action in self.actions:
            all_tags.update(action.tags)
        
        # Create memory
        memory = ShortTermMemory(
            action_count=self.action_count,
            actions=self.actions.copy(),
            learning=learning,
            next_steps=next_steps,
            timestamp=time.time(),
            tags=sorted(all_tags)
        )
        
        # Save to file
        self._save_memory(memory)
        
        # Clear action buffer
        self.actions = []
        
        # Cleanup if too many short-term memories
        self._cleanup_old_memories()
    
    def _extract_learning(self) -> str:
        """Extract learning from recent actions."""
        if not self.actions:
            return "No actions recorded yet."
        
        # Analyze patterns in actions
        action_types = [a.action_type for a in self.actions]
        outcomes = [a.outcome for a in self.actions]
        
        learning_points = []
        
        # Pattern: What types of actions were taken?
        type_summary = {}
        for t in action_types:
            type_summary[t] = type_summary.get(t, 0) + 1
        
        if type_summary:
            most_common = max(type_summary.items(), key=lambda x: x[1])
            learning_points.append(
                f"Primary focus: {most_common[0]} ({most_common[1]} times)"
            )
        
        # Pattern: Success rate
        successes = sum(1 for o in outcomes if o and ('success' in o.lower() or 'complete' in o.lower()))
        if successes > 0:
            learning_points.append(f"{successes}/{len(outcomes)} actions successful")
        
        # Extract key learnings from outcomes
        for action in self.actions:
            if action.outcome and len(action.outcome) > 20:
                learning_points.append(f"- {action.outcome[:100]}")
        
        return "\n".join(learning_points[:5]) if learning_points else "Actions completed."
    
    def _determine_next_steps(self) -> str:
        """Determine next steps based on recent actions."""
        if not self.actions:
            return "Continue with next phase."
        
        # Look at last action
        last_action = self.actions[-1]
        
        # Simple heuristic-based next steps
        next_steps = []
        
        if 'test' in last_action.action_type.lower():
            next_steps.append("Verify test results and fix any failures")
        elif 'implement' in last_action.action_type.lower() or 'create' in last_action.action_type.lower():
            next_steps.append("Test the implementation")
            next_steps.append("Document the changes")
        elif 'audit' in last_action.action_type.lower() or 'analyze' in last_action.action_type.lower():
            next_steps.append("Act on insights from analysis")
        
        # Default
        if not next_steps:
            next_steps.append("Continue with next phase of work")
        
        return "\n".join(f"{i}. {step}" for i, step in enumerate(next_steps, 1))
    
    def _save_memory(self, memory: ShortTermMemory):
        """Save memory to file."""
        dt = datetime.fromtimestamp(memory.timestamp)
        filename = f"{dt.strftime('%Y%m%d_%H%M%S')}_action_{memory.action_count:04d}.md"
        filepath = self.short_term_dir / filename
        
        with open(filepath, 'w') as f:
            f.write(memory.to_markdown())
    
    def _cleanup_old_memories(self):
        """Keep only the most recent N short-term memories."""
        memories = sorted(self.short_term_dir.glob("*.md"))
        
        if len(memories) > self.max_short_term:
            # Remove oldest
            to_remove = memories[:-self.max_short_term]
            for path in to_remove:
                # Archive before deleting (move to archive subfolder)
                archive_dir = self.short_term_dir / "archive"
                archive_dir.mkdir(exist_ok=True)
                path.rename(archive_dir / path.name)
    
    def get_stats(self) -> Dict[str, Any]:
        """Get capture statistics."""
        memories = list(self.short_term_dir.glob("*.md"))
        
        return {
            "total_actions": self.action_count,
            "short_term_memories": len(memories),
            "pending_actions": len(self.actions),
            "next_capture_in": self.frequency - len(self.actions),
            "max_short_term": self.max_short_term
        }


# Global instance (singleton pattern)
_capture_instance: Optional[MemoryCapture] = None


def get_capture(frequency: Optional[int] = None) -> MemoryCapture:
    """Get global memory capture instance."""
    global _capture_instance
    
    if _capture_instance is None:
        freq = frequency or int(os.getenv('WHITEMAGIC_MEMORY_FREQUENCY', '5'))
        _capture_instance = MemoryCapture(frequency=freq)
    
    return _capture_instance


def record_action(action_type: str, description: str, **kwargs):
    """Convenience function to record action."""
    capture = get_capture()
    capture.record_action(action_type, description, **kwargs)


def capture_now():
    """Force capture current actions."""
    capture = get_capture()
    capture.capture_memory(force=True)
